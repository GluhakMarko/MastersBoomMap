{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nvar __jsx = React.createElement;\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React from 'react';\nimport L from 'leaflet';\nimport 'leaflet/dist/leaflet.css';\nimport myData from '../../src/data/results_json';\nimport request from 'request';\nimport \"leaflet.awesome-markers/dist/leaflet.awesome-markers.css\";\nimport \"leaflet.awesome-markers/dist/leaflet.awesome-markers\";\nimport { Map, TileLayer, Marker, Popup } from 'react-leaflet';\nvar weather = {\n  Clear: 'J',\n  Rain: 'D',\n  Clouds: 'O',\n  Snow: 'S',\n  Fog: 'M'\n};\nvar marker = {\n  coords: [46.1491664, 14.9860106],\n  locText: \"test\",\n  iconColor: \"\",\n  criticalState: 0\n};\n\nvar StreetMap = /*#__PURE__*/function (_React$Component) {\n  _inherits(StreetMap, _React$Component);\n\n  var _super = _createSuper(StreetMap);\n\n  function StreetMap(props) {\n    var _this;\n\n    _classCallCheck(this, StreetMap);\n\n    _this = _super.call(this, props);\n\n    _defineProperty(_assertThisInitialized(_this), \"changeFilterOptions\", function (filter, surface) {\n      _this.state.markers = [];\n\n      _this.setState({\n        filterOptions: filter\n      });\n\n      _this.state.surface = surface;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"getLocation\", function () {\n      if (navigator.geolocation) {\n        var position = navigator.geolocation.getCurrentPosition(_this.geoSuccess);\n      } else {\n        alert(\"Not supported\");\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"geoSuccess\", function (position) {\n      var lat = position.coords.latitude;\n      var lng = position.coords.longitude;\n\n      _this.setState({\n        currentLoc: {\n          lat: lat,\n          long: lng\n        }\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"getWeatherData\", function (lat, lon) {\n      fetch('http://api.openweathermap.org/data/2.5/find?lat=' + lat + '&lon=' + lon + '&cnt=1&APPID=19117506641d90371c01ce010e35f032').then(function (res) {\n        return res.json();\n      }).then(function (json) {\n        return _this.setState({\n          weatherD: json.list[0].weather[0].main\n        });\n      });\n      /* let url = 'http://api.openweathermap.org/data/2.5/find?lat='+lat+'&lon='+lon+'&cnt=1&APPID=19117506641d90371c01ce010e35f032';\n       request({url,json:true},(error,{body})=>{\n           let d = body.list[0].weather[0].main;\n           this.setState({weatherD: d})\n       }) */\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"getCurrentState\", function () {\n      var date = new Date();\n      var day = date.getDay() !== 0 ? date.getDay() + 1 : 6;\n      var month = date.getMonth() !== 12 ? date.getMonth() + 1 : 0; //assign surface at current time\n\n      var surface = \"\";\n\n      switch (weather[_this.state.weatherD]) {\n        case \"D\":\n          surface = {\n            general: 'ne_suho',\n            type: \"MO\"\n          };\n          break;\n\n        case \"S\":\n          surface = {\n            general: 'ne_suho',\n            type: \"SL\"\n          };\n          break;\n\n        default:\n          surface = {\n            general: 'suho',\n            type: \"SU\"\n          };\n          break;\n      }\n\n      var current = {\n        PRVR_Vreme: weather[_this.state.weatherD],\n        Cas_Nesrece: date.getHours().toString() + '.0',\n        dan_v_tednu: day.toString(),\n        mesec: month.toString(),\n        PRPV_Povrsje: surface\n      };\n      return current;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"isSectionCritical\", function (section, surfaceType) {\n      var state = Object.keys(_this.state.filterOptions).length !== 0 ? _this.state.filterOptions : _this.getCurrentState();\n      var count = 0;\n\n      if (myData[section][\"dan_teden\"].includes(parseInt(state['dan_v_tednu']))) {\n        count++;\n      }\n\n      var section_attributes = myData[section]['povrsje'][state['PRPV_Povrsje']['general']];\n\n      for (var attribute in state) {\n        if (attribute === 'PRPV_Povrsje') {\n          if (section_attributes[attribute].includes(state[attribute]['type']) && attribute !== 'dan_v_tednu') count++;\n        } else {\n          if (section_attributes[attribute].includes(state[attribute]) && attribute !== 'dan_v_tednu') count++;\n        }\n      }\n\n      return count;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"setMarkerColor\", function (criticalState) {\n      var url = 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png';\n\n      switch (criticalState) {\n        case 5:\n          url = 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png';\n\n        case 4:\n          url = 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png';\n          break;\n\n        case 3:\n          url = 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-orange.png';\n          break;\n\n        case 2:\n          url = 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-green.png';\n          break;\n\n        case 1:\n          url = 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-green.png';\n          break;\n      }\n\n      return url;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"setMarkersBasedOnLegend\", function (criticalState, marker) {\n      var isLegendEmpty = !Object.values(_this.state.criticalLevelsChecked).includes(true);\n      var legendKeys = Object.keys(_this.state.criticalLevelsChecked);\n      marker.iconColor = _this.setMarkerColor(criticalState);\n\n      if (criticalState >= 1) {\n        if (isLegendEmpty) _this.state.markers.push(marker);else {\n          for (var i = 0; i < legendKeys.length; i++) {\n            if (_this.state.criticalLevelsChecked[legendKeys[i]] && criticalState.toString() === legendKeys[i]) _this.state.markers.push(marker);\n          }\n        }\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"addMarkers\", function () {\n      for (var section in myData) {\n        if (!myData[section].koordinate.includes(null)) {\n          var coord = myData[section].koordinate.toString().split(',');\n          marker = {\n            coords: [coord[0], coord[1]],\n            locText: myData[section].kraj[0][3].toString(),\n            iconColor: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png'\n          };\n\n          if (_this.state.selectedOption === 'all') {\n            if (Object.keys(_this.state.filterOptions).length === 0) _this.state.markers.push(marker);else _this.setMarkersBasedOnLegend(_this.isSectionCritical(section, _this.state.surface), marker);\n          } else {\n            var criticalState = _this.isSectionCritical(section, _this.state.selectedOption);\n\n            _this.setMarkersBasedOnLegend(criticalState, marker);\n          }\n        }\n      }\n    });\n\n    _this.state = {\n      lat: 46.1491664,\n      lng: 14.9860106,\n      zoom: 9,\n      selectedOption: \"current\",\n      criticalLevelsChecked: {\n        '4': false,\n        '3': false,\n        '2': false\n      },\n      filterOptions: {},\n      markers: [],\n      surface: '',\n      weatherD: '',\n      currentLoc: {\n        lat: 46.1491664,\n        lng: 14.9860106\n      }\n    };\n    return _this;\n  }\n\n  _createClass(StreetMap, [{\n    key: \"changeOption\",\n    value: function changeOption(newOption) {\n      this.setState({\n        markers: []\n      });\n      this.setState({\n        filterOptions: {}\n      });\n      this.setState({\n        selectedOption: newOption.value\n      });\n    }\n  }, {\n    key: \"changeCriticalLevel\",\n    value: function changeCriticalLevel(newLevel) {\n      this.state.markers = [];\n      this.setState({\n        criticalLevelsChecked: newLevel\n      });\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.getWeatherData(this.state.currentLoc.lat, this.state.currentLoc.lng);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      this.getLocation();\n      this.addMarkers();\n      var position = [this.state.lat, this.state.lng];\n      return __jsx(Map, {\n        className: \"map\",\n        center: position,\n        zoom: this.state.zoom\n      }, __jsx(TileLayer, {\n        attribution: \"&copy <a href=\\\"http://osm.org/copyright\\\">OpenStreetMap</a> contributors\",\n        url: \"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\"\n      }), this.state.markers.map(function (m, idx) {\n        return __jsx(Marker, {\n          key: \"marker-\".concat(idx),\n          position: m.coords,\n          icon: L.icon({\n            iconUrl: m.iconColor,\n            iconSize: [30, 50],\n            iconAnchor: [22, 50],\n            shadowAnchor: [4, 62],\n            // the same for the shadow\n            popupAnchor: [-6, -35]\n          })\n        }, __jsx(Popup, null, __jsx(\"span\", null, m.locText)));\n      }));\n    }\n  }]);\n\n  return StreetMap;\n}(React.Component);\n\nexport default StreetMap;","map":null,"metadata":{},"sourceType":"module"}