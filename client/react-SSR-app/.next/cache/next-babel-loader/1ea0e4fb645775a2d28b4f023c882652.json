{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React from 'react';\nimport L from 'leaflet';\nimport 'leaflet/dist/leaflet.css';\nimport myData from '../../src/data/results_json';\nimport request from 'request';\nimport \"leaflet.awesome-markers/dist/leaflet.awesome-markers.css\";\nimport \"leaflet.awesome-markers/dist/leaflet.awesome-markers\";\nimport { Map, TileLayer, Marker, Popup } from 'react-leaflet';\nlet weather = {\n  Clear: 'J',\n  Rain: 'D',\n  Clouds: 'O',\n  Snow: 'S',\n  Fog: 'M'\n};\nvar marker = {\n  coords: [46.1491664, 14.9860106],\n  locText: \"test\",\n  iconColor: \"\",\n  criticalState: 0\n};\n\nclass StreetMap extends React.Component {\n  constructor(props) {\n    super(props);\n\n    _defineProperty(this, \"changeFilterOptions\", (filter, surface) => {\n      this.state.markers = [];\n      this.setState({\n        filterOptions: filter\n      });\n      this.state.surface = surface;\n    });\n\n    _defineProperty(this, \"getLocation\", () => {\n      if (navigator.geolocation) {\n        let position = navigator.geolocation.getCurrentPosition(this.geoSuccess);\n      } else {\n        alert(\"Not supported\");\n      }\n    });\n\n    _defineProperty(this, \"geoSuccess\", position => {\n      var lat = position.coords.latitude;\n      var lng = position.coords.longitude;\n      this.setState({\n        currentLoc: {\n          lat: lat,\n          long: lng\n        }\n      });\n    });\n\n    _defineProperty(this, \"getWeatherData\", (lat, lon) => {\n      fetch('http://api.openweathermap.org/data/2.5/find?lat=' + lat + '&lon=' + lon + '&cnt=1&APPID=19117506641d90371c01ce010e35f032').then(res => res.json()).then(json => this.setState({\n        weatherD: json.list[0].weather[0].main\n      }));\n      /* let url = 'http://api.openweathermap.org/data/2.5/find?lat='+lat+'&lon='+lon+'&cnt=1&APPID=19117506641d90371c01ce010e35f032';\n       request({url,json:true},(error,{body})=>{\n           let d = body.list[0].weather[0].main;\n           this.setState({weatherD: d})\n       }) */\n    });\n\n    _defineProperty(this, \"getCurrentState\", () => {\n      let date = new Date();\n      let day = date.getDay() !== 0 ? date.getDay() + 1 : 6;\n      let month = date.getMonth() !== 12 ? date.getMonth() + 1 : 0; //assign surface at current time\n\n      let surface = \"\";\n\n      switch (weather[this.state.weatherD]) {\n        case \"D\":\n          surface = {\n            general: 'ne_suho',\n            type: \"MO\"\n          };\n          break;\n\n        case \"S\":\n          surface = {\n            general: 'ne_suho',\n            type: \"SL\"\n          };\n          break;\n\n        default:\n          surface = {\n            general: 'suho',\n            type: \"SU\"\n          };\n          break;\n      }\n\n      let current = {\n        PRVR_Vreme: weather[this.state.weatherD],\n        Cas_Nesrece: date.getHours().toString() + '.0',\n        dan_v_tednu: day.toString(),\n        mesec: month.toString(),\n        PRPV_Povrsje: surface\n      };\n      return current;\n    });\n\n    _defineProperty(this, \"isSectionCritical\", (section, surfaceType) => {\n      let state = Object.keys(this.state.filterOptions).length !== 0 ? this.state.filterOptions : this.getCurrentState();\n      let count = 0;\n\n      if (myData[section][\"dan_teden\"].includes(parseInt(state['dan_v_tednu']))) {\n        count++;\n      }\n\n      let section_attributes = myData[section]['povrsje'][state['PRPV_Povrsje']['general']];\n\n      for (let attribute in state) {\n        if (attribute === 'PRPV_Povrsje') {\n          if (section_attributes[attribute].includes(state[attribute]['type']) && attribute !== 'dan_v_tednu') count++;\n        } else {\n          if (section_attributes[attribute].includes(state[attribute]) && attribute !== 'dan_v_tednu') count++;\n        }\n      }\n\n      return count;\n    });\n\n    _defineProperty(this, \"setMarkerColor\", criticalState => {\n      let url = 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png';\n\n      switch (criticalState) {\n        case 5:\n          url = 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png';\n\n        case 4:\n          url = 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png';\n          break;\n\n        case 3:\n          url = 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-orange.png';\n          break;\n\n        case 2:\n          url = 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-green.png';\n          break;\n\n        case 1:\n          url = 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-green.png';\n          break;\n      }\n\n      return url;\n    });\n\n    _defineProperty(this, \"setMarkersBasedOnLegend\", (criticalState, marker) => {\n      let isLegendEmpty = !Object.values(this.state.criticalLevelsChecked).includes(true);\n      let legendKeys = Object.keys(this.state.criticalLevelsChecked);\n      marker.iconColor = this.setMarkerColor(criticalState);\n\n      if (criticalState >= 1) {\n        if (isLegendEmpty) this.state.markers.push(marker);else {\n          for (let i = 0; i < legendKeys.length; i++) {\n            if (this.state.criticalLevelsChecked[legendKeys[i]] && criticalState.toString() === legendKeys[i]) this.state.markers.push(marker);\n          }\n        }\n      }\n    });\n\n    _defineProperty(this, \"addMarkers\", () => {\n      for (let section in myData) {\n        if (!myData[section].koordinate.includes(null)) {\n          let coord = myData[section].koordinate.toString().split(',');\n          marker = {\n            coords: [coord[0], coord[1]],\n            locText: myData[section].kraj[0][3].toString(),\n            iconColor: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png'\n          };\n\n          if (this.state.selectedOption === 'all') {\n            if (Object.keys(this.state.filterOptions).length === 0) this.state.markers.push(marker);else this.setMarkersBasedOnLegend(this.isSectionCritical(section, this.state.surface), marker);\n          } else {\n            let criticalState = this.isSectionCritical(section, this.state.selectedOption);\n            this.setMarkersBasedOnLegend(criticalState, marker);\n          }\n        }\n      }\n    });\n\n    this.state = {\n      lat: 46.1491664,\n      lng: 14.9860106,\n      zoom: 9,\n      selectedOption: \"current\",\n      criticalLevelsChecked: {\n        '4': false,\n        '3': false,\n        '2': false\n      },\n      filterOptions: {},\n      markers: [],\n      surface: '',\n      weatherD: '',\n      currentLoc: {\n        lat: 46.1491664,\n        lng: 14.9860106\n      }\n    };\n  }\n\n  changeOption(newOption) {\n    this.setState({\n      markers: []\n    });\n    this.setState({\n      filterOptions: {}\n    });\n    this.setState({\n      selectedOption: newOption.value\n    });\n  }\n\n  changeCriticalLevel(newLevel) {\n    this.state.markers = [];\n    this.setState({\n      criticalLevelsChecked: newLevel\n    });\n  }\n\n  componentDidMount() {\n    this.getWeatherData(this.state.currentLoc.lat, this.state.currentLoc.lng);\n  }\n\n  render() {\n    this.getLocation();\n    this.addMarkers();\n    const position = [this.state.lat, this.state.lng];\n    return __jsx(Map, {\n      className: \"map\",\n      center: position,\n      zoom: this.state.zoom\n    }, __jsx(TileLayer, {\n      attribution: \"&copy <a href=\\\"http://osm.org/copyright\\\">OpenStreetMap</a> contributors\",\n      url: \"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\"\n    }), this.state.markers.map((m, idx) => __jsx(Marker, {\n      key: `marker-${idx}`,\n      position: m.coords,\n      icon: L.icon({\n        iconUrl: m.iconColor,\n        iconSize: [30, 50],\n        iconAnchor: [22, 50],\n        shadowAnchor: [4, 62],\n        // the same for the shadow\n        popupAnchor: [-6, -35]\n      })\n    }, __jsx(Popup, null, __jsx(\"span\", null, m.locText)))));\n  }\n\n}\n\nexport default StreetMap;","map":null,"metadata":{},"sourceType":"module"}